const mongoose = require('mongoose');\nconst Dispute = require('../../models/Dispute');\nconst User = require('../../models/User');\n\ndescribe('Dispute Model', () => {\n    let testUser1, testUser2, testMediator;\n\n    beforeEach(async () => {\n        // Create test users\n        testUser1 = new User({\n            fullName: 'Test User 1',\n            email: 'testuser1@example.com',\n            password: 'password123',\n            role: 'freelancer'\n        });\n        await testUser1.save();\n\n        testUser2 = new User({\n            fullName: 'Test User 2',\n            email: 'testuser2@example.com',\n            password: 'password123',\n            role: 'client'\n        });\n        await testUser2.save();\n\n        testMediator = new User({\n            fullName: 'Test Mediator',\n            email: 'mediator@example.com',\n            password: 'password123',\n            role: 'admin'\n        });\n        await testMediator.save();\n    });\n\n    afterEach(async () => {\n        await Dispute.deleteMany({});\n        await User.deleteMany({});\n    });\n\n    describe('Dispute Creation', () => {\n        it('should create a dispute with valid data', async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Payment Dispute',\n                description: 'Client has not paid for completed work'\n            };\n\n            const dispute = await Dispute.createDispute(disputeData);\n\n            expect(dispute).toBeDefined();\n            expect(dispute.disputeType).toBe('project_dispute');\n            expect(dispute.title).toBe('Payment Dispute');\n            expect(dispute.status).toBe('pending');\n            expect(dispute.priority).toBe('medium');\n            expect(dispute.timeline).toHaveLength(1);\n            expect(dispute.timeline[0].action).toBe('created');\n        });\n\n        it('should require all mandatory fields', async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                // Missing required fields\n            };\n\n            await expect(Dispute.createDispute(disputeData)).rejects.toThrow();\n        });\n\n        it('should validate dispute type', async () => {\n            const disputeData = {\n                disputeType: 'invalid_type',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Test Dispute',\n                description: 'Test description'\n            };\n\n            await expect(Dispute.createDispute(disputeData)).rejects.toThrow();\n        });\n    });\n\n    describe('Mediator Assignment', () => {\n        let dispute;\n\n        beforeEach(async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Test Dispute',\n                description: 'Test description'\n            };\n            dispute = await Dispute.createDispute(disputeData);\n        });\n\n        it('should assign mediator successfully', async () => {\n            const updatedDispute = await Dispute.assignMediator(dispute._id, testMediator._id);\n\n            expect(updatedDispute.assignedMediatorId.toString()).toBe(testMediator._id.toString());\n            expect(updatedDispute.status).toBe('under_review');\n            expect(updatedDispute.timeline).toHaveLength(2);\n            expect(updatedDispute.timeline[1].action).toBe('assigned');\n        });\n\n        it('should throw error for non-existent dispute', async () => {\n            const fakeId = new mongoose.Types.ObjectId();\n            await expect(Dispute.assignMediator(fakeId, testMediator._id)).rejects.toThrow('Dispute not found');\n        });\n    });\n\n    describe('Message Management', () => {\n        let dispute;\n\n        beforeEach(async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Test Dispute',\n                description: 'Test description'\n            };\n            dispute = await Dispute.createDispute(disputeData);\n        });\n\n        it('should add message successfully', async () => {\n            const message = 'This is a test message';\n            const updatedDispute = await dispute.addMessage(testUser1._id, message);\n\n            expect(updatedDispute.messages).toHaveLength(1);\n            expect(updatedDispute.messages[0].content).toBe(message);\n            expect(updatedDispute.messages[0].senderId.toString()).toBe(testUser1._id.toString());\n            expect(updatedDispute.messages[0].isInternal).toBe(false);\n            expect(updatedDispute.timeline).toHaveLength(2);\n        });\n\n        it('should add internal message', async () => {\n            const message = 'Internal note';\n            const updatedDispute = await dispute.addMessage(testMediator._id, message, true);\n\n            expect(updatedDispute.messages).toHaveLength(1);\n            expect(updatedDispute.messages[0].isInternal).toBe(true);\n        });\n\n        it('should add message with attachments', async () => {\n            const message = 'Message with attachment';\n            const attachments = [{\n                name: 'evidence.pdf',\n                url: 'https://example.com/evidence.pdf',\n                type: 'application/pdf'\n            }];\n\n            const updatedDispute = await dispute.addMessage(testUser1._id, message, false, attachments);\n\n            expect(updatedDispute.messages[0].attachments).toHaveLength(1);\n            expect(updatedDispute.messages[0].attachments[0].name).toBe('evidence.pdf');\n        });\n    });\n\n    describe('Status Updates', () => {\n        let dispute;\n\n        beforeEach(async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Test Dispute',\n                description: 'Test description'\n            };\n            dispute = await Dispute.createDispute(disputeData);\n        });\n\n        it('should update status successfully', async () => {\n            const newStatus = 'mediation';\n            const updatedDispute = await dispute.updateStatus(newStatus, testMediator._id, 'Moving to mediation');\n\n            expect(updatedDispute.status).toBe(newStatus);\n            expect(updatedDispute.timeline).toHaveLength(2);\n            expect(updatedDispute.timeline[1].action).toBe('status_changed');\n            expect(updatedDispute.timeline[1].metadata.newStatus).toBe(newStatus);\n        });\n\n        it('should validate status values', async () => {\n            await expect(dispute.updateStatus('invalid_status', testMediator._id)).rejects.toThrow();\n        });\n    });\n\n    describe('Dispute Resolution', () => {\n        let dispute;\n\n        beforeEach(async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Test Dispute',\n                description: 'Test description'\n            };\n            dispute = await Dispute.createDispute(disputeData);\n        });\n\n        it('should resolve dispute successfully', async () => {\n            const resolution = {\n                outcome: 'upheld',\n                description: 'Dispute resolved in favor of initiator',\n                compensationAwarded: {\n                    amount: 500,\n                    currency: 'USD',\n                    recipient: testUser1._id\n                },\n                actionsTaken: [{\n                    action: 'payment_processed',\n                    target: 'client',\n                    description: 'Payment released to freelancer'\n                }]\n            };\n\n            const resolvedDispute = await dispute.resolve(resolution, testMediator._id);\n\n            expect(resolvedDispute.status).toBe('resolved');\n            expect(resolvedDispute.resolution.outcome).toBe('upheld');\n            expect(resolvedDispute.resolution.resolvedBy.toString()).toBe(testMediator._id.toString());\n            expect(resolvedDispute.resolution.resolvedAt).toBeDefined();\n            expect(resolvedDispute.resolution.compensationAwarded.amount).toBe(500);\n            expect(resolvedDispute.timeline).toHaveLength(2);\n        });\n\n        it('should validate resolution outcome', async () => {\n            const resolution = {\n                outcome: 'invalid_outcome',\n                description: 'Invalid resolution'\n            };\n\n            await expect(dispute.resolve(resolution, testMediator._id)).rejects.toThrow();\n        });\n    });\n\n    describe('Dispute Queue', () => {\n        beforeEach(async () => {\n            // Create multiple disputes for testing\n            const disputes = [\n                {\n                    disputeType: 'project_dispute',\n                    relatedId: new mongoose.Types.ObjectId(),\n                    relatedType: 'Project',\n                    initiatedBy: testUser1._id,\n                    respondent: testUser2._id,\n                    title: 'Dispute 1',\n                    description: 'First dispute',\n                    priority: 'high'\n                },\n                {\n                    disputeType: 'payment_dispute',\n                    relatedId: new mongoose.Types.ObjectId(),\n                    relatedType: 'Project',\n                    initiatedBy: testUser2._id,\n                    respondent: testUser1._id,\n                    title: 'Dispute 2',\n                    description: 'Second dispute',\n                    priority: 'low'\n                }\n            ];\n\n            for (const disputeData of disputes) {\n                await Dispute.createDispute(disputeData);\n            }\n        });\n\n        it('should get dispute queue with pagination', async () => {\n            const result = await Dispute.getDisputeQueue({ page: 1, limit: 10 });\n\n            expect(result.disputes).toHaveLength(2);\n            expect(result.pagination.total).toBe(2);\n            expect(result.pagination.page).toBe(1);\n            expect(result.pagination.pages).toBe(1);\n        });\n\n        it('should filter by status', async () => {\n            const result = await Dispute.getDisputeQueue({ status: 'pending' });\n\n            expect(result.disputes).toHaveLength(2);\n            result.disputes.forEach(dispute => {\n                expect(dispute.status).toBe('pending');\n            });\n        });\n\n        it('should filter by dispute type', async () => {\n            const result = await Dispute.getDisputeQueue({ disputeType: 'project_dispute' });\n\n            expect(result.disputes).toHaveLength(1);\n            expect(result.disputes[0].disputeType).toBe('project_dispute');\n        });\n\n        it('should sort by priority', async () => {\n            const result = await Dispute.getDisputeQueue();\n\n            // Should be sorted by priority (high first) then by creation date\n            expect(result.disputes[0].priority).toBe('high');\n            expect(result.disputes[1].priority).toBe('low');\n        });\n    });\n\n    describe('Statistics', () => {\n        beforeEach(async () => {\n            // Create disputes with different statuses and outcomes\n            const disputes = [\n                {\n                    disputeType: 'project_dispute',\n                    relatedId: new mongoose.Types.ObjectId(),\n                    relatedType: 'Project',\n                    initiatedBy: testUser1._id,\n                    respondent: testUser2._id,\n                    title: 'Resolved Dispute 1',\n                    description: 'First resolved dispute'\n                },\n                {\n                    disputeType: 'payment_dispute',\n                    relatedId: new mongoose.Types.ObjectId(),\n                    relatedType: 'Project',\n                    initiatedBy: testUser2._id,\n                    respondent: testUser1._id,\n                    title: 'Resolved Dispute 2',\n                    description: 'Second resolved dispute'\n                },\n                {\n                    disputeType: 'service_dispute',\n                    relatedId: new mongoose.Types.ObjectId(),\n                    relatedType: 'Project',\n                    initiatedBy: testUser1._id,\n                    respondent: testUser2._id,\n                    title: 'Pending Dispute',\n                    description: 'Still pending dispute'\n                }\n            ];\n\n            for (const disputeData of disputes) {\n                const dispute = await Dispute.createDispute(disputeData);\n                \n                // Resolve first two disputes\n                if (disputeData.title.includes('Resolved')) {\n                    await dispute.resolve({\n                        outcome: 'upheld',\n                        description: 'Test resolution'\n                    }, testMediator._id);\n                }\n            }\n        });\n\n        it('should get dispute statistics', async () => {\n            const stats = await Dispute.getStatistics(30);\n\n            expect(stats.total).toBe(3);\n            expect(stats.pending).toBe(1);\n            expect(stats.resolved).toBe(2);\n            expect(stats.resolutionRate).toBe(66.67); // 2/3 * 100, rounded\n            expect(stats.byType).toHaveProperty('project_dispute');\n            expect(stats.byType).toHaveProperty('payment_dispute');\n            expect(stats.byType).toHaveProperty('service_dispute');\n            expect(stats.byOutcome).toHaveProperty('upheld');\n        });\n\n        it('should calculate average resolution time', async () => {\n            const stats = await Dispute.getStatistics(30);\n\n            expect(stats.avgResolutionTime).toBeGreaterThanOrEqual(0);\n        });\n    });\n\n    describe('Virtual Properties', () => {\n        let dispute;\n\n        beforeEach(async () => {\n            const disputeData = {\n                disputeType: 'project_dispute',\n                relatedId: new mongoose.Types.ObjectId(),\n                relatedType: 'Project',\n                initiatedBy: testUser1._id,\n                respondent: testUser2._id,\n                title: 'Test Dispute',\n                description: 'Test description'\n            };\n            dispute = await Dispute.createDispute(disputeData);\n        });\n\n        it('should calculate age correctly', async () => {\n            const age = dispute.age;\n            expect(age).toBeGreaterThan(0);\n        });\n\n        it('should calculate response time for resolved disputes', async () => {\n            await dispute.resolve({\n                outcome: 'upheld',\n                description: 'Test resolution'\n            }, testMediator._id);\n\n            const responseTime = dispute.responseTime;\n            expect(responseTime).toBeGreaterThan(0);\n        });\n\n        it('should return null response time for unresolved disputes', () => {\n            const responseTime = dispute.responseTime;\n            expect(responseTime).toBeNull();\n        });\n    });\n});"